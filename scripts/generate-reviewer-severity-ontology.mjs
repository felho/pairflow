#!/usr/bin/env node

import { mkdir, readFile, writeFile } from "node:fs/promises";
import { dirname, resolve } from "node:path";
import { fileURLToPath } from "node:url";

const runtimeReminderStartMarker = "<!-- pairflow:runtime-reminder:start -->";
const runtimeReminderEndMarker = "<!-- pairflow:runtime-reminder:end -->";
const sourceDocRelativePath = "docs/reviewer-severity-ontology.md";
const generatedModuleRelativePath =
  "src/core/runtime/reviewerSeverityOntology.generated.ts";

function readRuntimeReminderBlock(markdown) {
  const startIndex = markdown.indexOf(runtimeReminderStartMarker);
  const endIndex = markdown.indexOf(runtimeReminderEndMarker);

  if (startIndex < 0 || endIndex < 0 || endIndex <= startIndex) {
    throw new Error(
      `Missing or invalid runtime reminder markers in ${sourceDocRelativePath}.`
    );
  }

  const block = markdown
    .slice(startIndex + runtimeReminderStartMarker.length, endIndex)
    .trim();
  if (block.length === 0) {
    throw new Error(
      `Runtime reminder block in ${sourceDocRelativePath} is empty.`
    );
  }
  return block;
}

function flattenMarkdownToPromptText(markdown) {
  const markdownWithoutHtmlComments = markdown.replace(/<!--[\s\S]*?-->/gu, " ");

  const normalizedLines = markdownWithoutHtmlComments
    .split(/\r?\n/u)
    .map((line) => line.trim())
    .filter((line) => line.length > 0);

  const textLines = normalizedLines
    .filter((line) => !/^[-]{3,}$/u.test(line))
    .map((line) => {
      if (/^\|/.test(line)) {
        return line
          .split("|")
          .map((cell) => cell.trim())
          .filter((cell) => cell.length > 0 && !/^[-:]+$/u.test(cell))
          .join(" ");
      }

      return line
        .replace(/^#{1,6}\s+/u, "")
        .replace(/^[-*+]\s+/u, "")
        .replace(/^\d+\.\s+/u, "");
    })
    .filter((line) => line.length > 0);

  return textLines.join(" ").replace(/\s+/gu, " ").trim();
}

async function main() {
  const repoRoot = resolve(dirname(fileURLToPath(import.meta.url)), "..");
  const sourceDocPath = resolve(repoRoot, sourceDocRelativePath);
  const generatedModulePath = resolve(repoRoot, generatedModuleRelativePath);

  const sourceMarkdown = await readFile(sourceDocPath, "utf8");
  const fullOntologyMarkdown = sourceMarkdown.trimEnd();
  const runtimeReminderMarkdown = readRuntimeReminderBlock(sourceMarkdown);
  const runtimeReminderText = flattenMarkdownToPromptText(
    runtimeReminderMarkdown
  );
  const fullOntologyPromptText = flattenMarkdownToPromptText(fullOntologyMarkdown);

  const generatedContent = [
    "// Auto-generated by scripts/generate-reviewer-severity-ontology.mjs.",
    `// Source: ${sourceDocRelativePath}`,
    "// Do not edit manually.",
    "",
    `export const reviewerSeverityOntologySourceDoc = ${JSON.stringify(sourceDocRelativePath)};`,
    `export const reviewerSeverityOntologyFullMarkdown = ${JSON.stringify(fullOntologyMarkdown)};`,
    `export const reviewerSeverityOntologyFullPromptText = ${JSON.stringify(fullOntologyPromptText)};`,
    `export const reviewerSeverityOntologyRuntimeBlockMarkdown = ${JSON.stringify(runtimeReminderMarkdown)};`,
    `export const reviewerSeverityOntologyRuntimeReminderText = ${JSON.stringify(runtimeReminderText)};`,
    ""
  ].join("\n");

  await mkdir(dirname(generatedModulePath), { recursive: true });
  await writeFile(generatedModulePath, generatedContent, "utf8");
}

main().catch((error) => {
  const message = error instanceof Error ? error.message : String(error);
  process.stderr.write(`Failed to generate reviewer ontology module: ${message}\n`);
  process.exitCode = 1;
});
