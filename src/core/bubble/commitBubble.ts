import { mkdir, readFile, writeFile } from "node:fs/promises";
import { dirname, isAbsolute, join, resolve } from "node:path";

import {
  appendProtocolEnvelope,
  readTranscriptEnvelopes
} from "../protocol/transcriptStore.js";
import { applyStateTransition } from "../state/machine.js";
import { readStateSnapshot, writeStateSnapshot } from "../state/stateStore.js";
import { runGit, GitCommandError } from "../workspace/git.js";
import { normalizeStringList } from "../util/normalize.js";
import { BubbleLookupError, resolveBubbleById } from "./bubbleLookup.js";
import type { BubbleStateSnapshot } from "../../types/bubble.js";
import type { ProtocolEnvelope } from "../../types/protocol.js";

export interface CommitBubbleInput {
  bubbleId: string;
  refs?: string[] | undefined;
  message?: string | undefined;
  auto?: boolean | undefined;
  repoPath?: string | undefined;
  cwd?: string | undefined;
  now?: Date | undefined;
}

export interface CommitBubbleResult {
  bubbleId: string;
  sequence: number;
  envelope: ProtocolEnvelope;
  state: BubbleStateSnapshot;
  commitSha: string;
  commitMessage: string;
  stagedFiles: string[];
  donePackagePath: string;
}

export class BubbleCommitError extends Error {
  public constructor(message: string) {
    super(message);
    this.name = "BubbleCommitError";
  }
}

function isPathInside(parentPath: string, childPath: string): boolean {
  const normalizedParent = resolve(parentPath);
  const normalizedChild = resolve(childPath);
  return (
    normalizedChild === normalizedParent ||
    normalizedChild.startsWith(`${normalizedParent}/`)
  );
}

function deriveDonePackageSummary(content: string): string {
  const lines = content
    .split(/\r?\n/u)
    .map((line) => line.trim())
    .filter((line) => line.length > 0 && !line.startsWith("#"));

  const candidate = lines[0] ?? "Done package attached.";
  const chars = Array.from(candidate);
  return chars.length > 240 ? `${chars.slice(0, 237).join("")}...` : candidate;
}

function extractPayloadSummary(envelope: ProtocolEnvelope): string | undefined {
  const payload = envelope.payload;
  if (
    typeof payload !== "object" ||
    payload === null ||
    Array.isArray(payload)
  ) {
    return undefined;
  }
  const summary = (payload as { summary?: unknown }).summary;
  if (typeof summary !== "string") {
    return undefined;
  }
  const trimmed = summary.trim();
  return trimmed.length > 0 ? trimmed : undefined;
}

function findLatestSummary(
  transcript: ProtocolEnvelope[],
  predicate: (envelope: ProtocolEnvelope) => boolean
): string | undefined {
  for (let index = transcript.length - 1; index >= 0; index -= 1) {
    const candidate = transcript[index];
    if (candidate === undefined || !predicate(candidate)) {
      continue;
    }
    const summary = extractPayloadSummary(candidate);
    if (summary !== undefined) {
      return summary;
    }
  }
  return undefined;
}

function renderAutoDonePackage(input: {
  bubbleId: string;
  round: number;
  generatedAt: string;
  convergenceSummary?: string;
  implementerSummary?: string;
  reviewerSummary?: string;
}): string {
  const convergenceSummary =
    input.convergenceSummary ?? "Convergence summary not available.";
  const implementerSummary =
    input.implementerSummary ?? "Implementer PASS summary not available.";
  const reviewerSummary =
    input.reviewerSummary ?? "Reviewer PASS summary not available.";

  return [
    "# Done Package",
    "",
    `Auto-generated by pairflow for bubble ${input.bubbleId} at ${input.generatedAt}.`,
    "",
    "## Bubble Context",
    `- Bubble ID: ${input.bubbleId}`,
    `- Round: ${input.round}`,
    "",
    "## Final Summary",
    convergenceSummary,
    "",
    "## Last Implementer PASS",
    implementerSummary,
    "",
    "## Last Reviewer PASS",
    reviewerSummary,
    "",
    "## Validation",
    "- [ ] Confirm tests/typecheck commands and outcomes",
    "- [ ] Confirm changed files are correct",
    "",
    "## Notes",
    "- Review and edit this document if you need a richer handoff package."
  ].join("\n");
}

async function readOrCreateDonePackage(input: {
  donePackagePath: string;
  transcriptPath: string;
  bubbleId: string;
  round: number;
  nowIso: string;
  autoGenerate: boolean;
  implementer: string;
  reviewer: string;
}): Promise<string> {
  const existing = await readFile(input.donePackagePath, "utf8").catch(
    (error: NodeJS.ErrnoException) => {
      if (error.code === "ENOENT") {
        return undefined;
      }
      throw error;
    }
  );
  if (existing !== undefined && existing.trim().length > 0) {
    return existing;
  }

  if (!input.autoGenerate) {
    if (existing === undefined) {
      throw new BubbleCommitError(
        `Missing done package artifact: ${input.donePackagePath}`
      );
    }
    throw new BubbleCommitError(
      `Done package artifact is empty: ${input.donePackagePath}`
    );
  }

  const transcript = await readTranscriptEnvelopes(input.transcriptPath, {
    allowMissing: true,
    toleratePartialFinalLine: true
  });
  const convergenceSummary = findLatestSummary(
    transcript,
    (entry) => entry.type === "CONVERGENCE"
  );
  const implementerSummary = findLatestSummary(
    transcript,
    (entry) => entry.type === "PASS" && entry.sender === input.implementer
  );
  const reviewerSummary = findLatestSummary(
    transcript,
    (entry) => entry.type === "PASS" && entry.sender === input.reviewer
  );

  const generated = renderAutoDonePackage({
    bubbleId: input.bubbleId,
    round: input.round,
    generatedAt: input.nowIso,
    ...(convergenceSummary !== undefined ? { convergenceSummary } : {}),
    ...(implementerSummary !== undefined ? { implementerSummary } : {}),
    ...(reviewerSummary !== undefined ? { reviewerSummary } : {})
  });
  await mkdir(dirname(input.donePackagePath), {
    recursive: true
  });
  await writeFile(input.donePackagePath, generated, "utf8");
  return generated;
}

async function collectStagedFiles(worktreePath: string): Promise<string[]> {
  const staged = await runGit(["diff", "--cached", "--name-only"], {
    cwd: worktreePath
  });
  return staged.stdout
    .split(/\r?\n/u)
    .map((line) => line.trim())
    .filter((line) => line.length > 0);
}

function assertStagedFilesWithinWorktree(
  stagedFiles: string[],
  worktreePath: string
): void {
  for (const file of stagedFiles) {
    if (isAbsolute(file)) {
      throw new BubbleCommitError(
        `Invalid staged file path (absolute path not allowed): ${file}`
      );
    }

    const absoluteFilePath = resolve(worktreePath, file);
    if (!isPathInside(worktreePath, absoluteFilePath)) {
      throw new BubbleCommitError(
        `Staged file is outside bubble worktree scope: ${file}`
      );
    }
  }
}

export async function commitBubble(
  input: CommitBubbleInput
): Promise<CommitBubbleResult> {
  const now = input.now ?? new Date();
  const nowIso = now.toISOString();
  const auto = input.auto ?? false;
  const refs = normalizeStringList(input.refs ?? []);

  const resolved = await resolveBubbleById({
    bubbleId: input.bubbleId,
    ...(input.repoPath !== undefined ? { repoPath: input.repoPath } : {}),
    ...(input.cwd !== undefined ? { cwd: input.cwd } : {})
  });
  const loadedState = await readStateSnapshot(resolved.bubblePaths.statePath);
  const state = loadedState.state;

  if (state.state !== "APPROVED_FOR_COMMIT") {
    throw new BubbleCommitError(
      `bubble commit can only be used while state is APPROVED_FOR_COMMIT (current: ${state.state}).`
    );
  }

  const donePackagePath = resolve(resolved.bubblePaths.artifactsDir, "done-package.md");
  const donePackageContent = await readOrCreateDonePackage({
    donePackagePath,
    transcriptPath: resolved.bubblePaths.transcriptPath,
    bubbleId: resolved.bubbleId,
    round: state.round,
    nowIso,
    autoGenerate: auto,
    implementer: resolved.bubbleConfig.agents.implementer,
    reviewer: resolved.bubbleConfig.agents.reviewer
  });

  if (auto) {
    await runGit(["add", "-A"], {
      cwd: resolved.bubblePaths.worktreePath
    });
  }

  const stagedFiles = await collectStagedFiles(resolved.bubblePaths.worktreePath);
  if (stagedFiles.length === 0) {
    throw new BubbleCommitError(
      auto
        ? "No staged files found in bubble worktree even after --auto stage-all."
        : "No staged files found in bubble worktree. Stage changes before commit, or use `pairflow bubble commit --auto`."
    );
  }

  assertStagedFilesWithinWorktree(stagedFiles, resolved.bubblePaths.worktreePath);

  const commitMessage = input.message ?? `bubble(${resolved.bubbleId}): finalize`;
  await runGit(["commit", "-m", commitMessage], {
    cwd: resolved.bubblePaths.worktreePath
  });
  const commitSha = (
    await runGit(["rev-parse", "HEAD"], {
      cwd: resolved.bubblePaths.worktreePath
    })
  ).stdout.trim();

  const envelopeRefs = normalizeStringList([...refs, donePackagePath]);
  const lockPath = join(resolved.bubblePaths.locksDir, `${resolved.bubbleId}.lock`);
  const appended = await appendProtocolEnvelope({
    transcriptPath: resolved.bubblePaths.transcriptPath,
    lockPath,
    now,
    envelope: {
      bubble_id: resolved.bubbleId,
      sender: "orchestrator",
      recipient: "human",
      type: "DONE_PACKAGE",
      round: state.round,
      payload: {
        summary: deriveDonePackageSummary(donePackageContent),
        metadata: {
          done_package_path: donePackagePath,
          staged_files: stagedFiles,
          commit_message: commitMessage,
          commit_sha: commitSha
        }
      },
      refs: envelopeRefs
    }
  });

  const committed = applyStateTransition(state, {
    to: "COMMITTED",
    lastCommandAt: nowIso
  });
  const committedWritten = await writeStateSnapshot(
    resolved.bubblePaths.statePath,
    committed,
    {
      expectedFingerprint: loadedState.fingerprint,
      expectedState: "APPROVED_FOR_COMMIT"
    }
  );

  const done = applyStateTransition(committedWritten.state, {
    to: "DONE",
    activeAgent: null,
    activeRole: null,
    activeSince: null,
    lastCommandAt: nowIso
  });

  let written;
  try {
    written = await writeStateSnapshot(resolved.bubblePaths.statePath, done, {
      expectedFingerprint: committedWritten.fingerprint,
      expectedState: "COMMITTED"
    });
  } catch (error) {
    const reason = error instanceof Error ? error.message : String(error);
    throw new BubbleCommitError(
      `DONE_PACKAGE ${appended.envelope.id} was appended and git commit ${commitSha} completed, but DONE transition failed after COMMITTED state persisted. Transcript remains canonical; recover state from transcript tail. Root error: ${reason}`
    );
  }

  return {
    bubbleId: resolved.bubbleId,
    sequence: appended.sequence,
    envelope: appended.envelope,
    state: written.state,
    commitSha,
    commitMessage,
    stagedFiles,
    donePackagePath
  };
}

export function asBubbleCommitError(error: unknown): never {
  if (error instanceof BubbleCommitError) {
    throw error;
  }
  if (error instanceof BubbleLookupError) {
    throw new BubbleCommitError(error.message);
  }
  if (error instanceof GitCommandError) {
    throw new BubbleCommitError(error.message);
  }
  if (error instanceof Error) {
    throw new BubbleCommitError(error.message);
  }
  throw error;
}
